% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/myGRoverlapFunctions.R
\name{filterByScore}
\alias{filterByScore}
\title{Find the overlaps of GRangesList items to have only once each indice of each GRanges
maximizing the sum of scores or normed scores.}
\usage{
filterByScore(myGRsToOverlap, mAll = NULL, colWithScore = "score",
  useNormScore = T, verbose = F)
}
\arguments{
\item{myGRsToOverlap}{a GRangesList with items to overlap}

\item{mAll}{a dataframe obtained with findAllOverlap with all possible overlaps between items of GRangeList (default is NULL).}

\item{colWithScore}{the name of the column in the meta columns of the GRanges of the GRList
to use to choose the best overlap (default is `"score"``).}

\item{useNormScore}{a boolean to specify if the score of each GRanges should be normalized
so the sum of all scores is 1 before summing between the overlaps to maximize.}

\item{verbose}{logical (default is `FALSE`).}
}
\value{
a dataframe with column names which correspond to the names of the GRanges items of the GRList.
Each indice of each GRanges will be present. When indices from different columns are on the same row,
this means that the specified GRanges overlap (at least with another one).
}
\description{
Find the overlaps of GRangesList items to have only once each indice of each GRanges
maximizing the sum of scores or normed scores.
}
\examples{
gr1 <- GenomicRanges::GRanges(seqnames = "chr1",
ranges = IRanges::IRanges(start = c(1, 11, 199),
                         end = c(10, 12, 200)),
score = c(20, 30, 100))
gr2 <- GenomicRanges::GRanges(seqnames = "chr1",
                             ranges = IRanges::IRanges(start = c(5, 101),
                                                       end = c(15, 102)),
                             score = c(60, 90))
gr3 <- GenomicRanges::GRanges(seqnames = "chr1",
                             ranges = IRanges::IRanges(start = c(1, 100),
                                                       end = c(4, 120)),
                             score = c(1, 2))
grL <- list(first = gr1, second = gr2, third = gr3)
filterByScore(grL, useNormScore = TRUE)
filterByScore(grL, useNormScore = FALSE)
}
